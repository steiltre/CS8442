%        File: hw2.tex
%     Created: Thu Feb 16 02:00 PM 2017 C
% Last Change: Thu Feb 16 02:00 PM 2017 C
%

\documentclass[a4paper]{article}

\title{CSci 8442 Homework 2 }
\date{3/6/17}
\author{Trevor Steil}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{esint}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{bbm}
\usepackage{xcolor}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem*{claim}{Claim}
%\newtheorem*{problem}{Problem}
%\newtheorem*{lemma}{Lemma}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\supp}[1]{\mathop{\mathrm{supp}}\left(#1\right)}
\newcommand{\lip}[1]{\mathop{\mathrm{Lip}}\left(#1\right)}
\newcommand{\curl}{\mathrm{curl}}
\newcommand{\la}{\left \langle}
\newcommand{\ra}{\right \rangle}
\renewcommand{\vec}[1]{\mathbf{#1}}
\renewcommand{\div}{\mathrm{div}}

\newenvironment{problem}{\textbf{Problem.}}

\newenvironment{solution}[1][]{\emph{Solution #1}}

\algnewcommand{\Or}{\textbf{ or }}
\algnewcommand{\And}{\textbf{ or }}

\begin{document}
\maketitle

\begin{enumerate}
  \item
    \begin{problem}
      Let $P$ be any polygon, possibly with holes.
      \begin{enumerate}
        \item Prove that there always exists a triangulation of $P$. (Consider reducing $P$ to a polygon with one fewer hole and applying induction.)
        \item Derive exact expressions for the number of triangles and the number of diagonals in any triangulation of $P$, as a function of the
          number, $n$, of vertices and the number, $h$, of holes in $P$. (Consider making an educated guess for the expressions and verifying these by
          induction on $h$.)
      \end{enumerate}
    \end{problem}

    \begin{solution}
      \begin{enumerate}
        \item
          We have the existence of a triangulation by noting that the discussion of splitting a polygon into $y$-monotone pieces holds whether $P$ has
          holes or not. Merge and split vertices are defined locally, so the definition holds for vertices on the boundary of $P$ as well as holes
          inside of $P$.

          The same algorithm as in the case without holes can be used to remove merge and split vertices by adding valid diagonals. As before, this means the original polygon
          has been split into $y$-monotone pieces. Each of these $y$-monotone pieces cannot contain a hole because this would create a $y$-value where
          a horizontal line would intersect in more than a single segment. Once we have the $y$-monotone pieces, we can triangulate in the same way.

        \item
          Consider a fully triangulated polygon with $h$ holes and $n$ vertices. Each face is one of the following: a triangle, a hole, or the
          exterior of the polygon. Therefore, there are $t + h + 1$ faces, where $t$ is the number of triangles in the triangulation. A simple polygon
          has the same number of edges as vertices as edges. Our original polygon is composed of simple polygons, so the number of edges bounding the
          exterior of the polygon and the interior of the holes is $n$. In the triangulated polygon, every edge is a diagonal or an edge in the
          original polygon. Therefore, we have $n + d$ egdes, where $d$ is the number of diagonals in the triangulation.

          Substituting these values into Euler's formula, we get
          \begin{align*}
            2 &= \# \text{faces} - \# \text{edges} + \# \text{vertices} \\
            &= (t + h + 1) - (n + d) + n \\
            &= t + h - d + 1
          \end{align*}
          This simplifies to
          \begin{equation}\label{eq:Euler_app}
            t + h - d = 1
          \end{equation}

          Now, consider walking around the edges of each triangle in the triangulation. Each triangle has 3 edges. Looking at the edges that are
          traversed in this way, we walk along each diagonal exactly twice and each edge of $P$ exactly once. This gives
          \[ 3t = 2d + n .\]

          Multiplying \eqref{eq:Euler_app} by 3 and inserting this relation, we have
          \begin{align*}
            3 &= 3t + 3h - 3d \\
            &= 3h + n - d
          \end{align*}
          This simplifies to $d = n - 3 + 3h$.

          Multiplying \eqref{eq:Euler_app} by 2 and again using the relation, we have
          \begin{align*}
            2 &= 2t + 2h - 2d \\
            &= 2t + 2h  - (3t - n) \\
            &= -t + 2h + n
          \end{align*}
          This simplifies to $t = n - 2 + 2h$.
      \end{enumerate}
    \end{solution}

  \item 5.13 page 120 \\
    \begin{problem}
      In many applications one wants to do range searching among objects other than points.
      \begin{enumerate}
        \item Let $S$ be a set of $n$ axis-parallel rectangles in the plane. We want to be able to report all rectangles in $S$ that are completely
          contained in a query rectangle $[x:x'] \times [y:y']$. Describe a data structure for this problem that uses $O(n \log^3 n)$ storage and has
          ${O(\log^4 n + k)}$ query time, where $k$ is the number of reported answers. Hint: Transform the problem to an orthogonal range searching
          problem in some higher-dimensional space.

        \item
          Let $P$ consist of a set of $n$ polygons in the plane. Again describe a data structure that uses $O(n \log^3 n)$ storage and has ${O(\log^4 n
          + k)}$ query time to report all polygons completely contained in the query rectangle, where $k$ is the number of reported answers.

        \item
          Improve the query time of your solutions (both a and b) to ${O(\log^3 n + k)}$.
      \end{enumerate}
    \end{problem}

    \begin{solution}
      \begin{enumerate}
        \item
          This query problem can be transformed into a query problem in 4-dimensions by recognizing we have 4 coordinates we are interested in for
          each rectangle in $S$: the $x$-coordinate of the left edge, the $x$-coordinate of the right edge, the $y$-coordinate of the bottom edge, and
          the $y$-coordinate of the top edge. Using this we can encode each rectangle using the coordinates $(x_l, x_r, y_b, y_t)$, where the
          coordinates are those listed previously.

          For querying against these points in $\R^4$, we query using the $x$-interval of our query rectangle twice in a row (using the same values
          each time), followed by two queries using the $y$-interval of our query rectangle. This query process returns a rectangle if and only if
          both $x$-coordinates and both $y$-coordinates of the point in $\R^4$ lie within the query rectangle (with two copies of its query
          intervals), that is, if and only if all edges are contained in the query rectangle.

          By using a range tree, we get the desired $O(n \log^3 n)$ storage and $O( \log^4 n + k)$ query time.

        \item
          This algorithm works the same way as that of part (a). Now we store each polygon in $P$ as $(x_l, x_r, y_b, y_t)$, where $x_l$ and $x_r$ are
          the left- and right-most $x$-coordinates of the polygon, and $y_b$ and $y_t$ are the smallest and largest $y$-coordinates of points in the
          polygon. By querying twice in each direction, we find all polygons in $P$ where all points have $x$- and $y$-coordinates in the ranges
          defined by the query rectangle.

          By using a range tree, we get the desired $O(n \log^3 n)$ storage and $O( \log^4 n + k)$ query time.

        \item Use fractional cascading on the $\R^2$ range trees constructed as part of the $\R^4$ range trees being used.
      \end{enumerate}
    \end{solution}

  \item 5.5 page 118 parts (a) and (b) \\
    \begin{problem}
      Algorithm \texttt{SearchKDTree} can also be used when querying with other ranges than rectangles. For example, a query is answered correctly if
      the range is a triangle.
      \begin{enumerate}
        \item
          Show that the query time for range queries with triangles is linear in the worst case, even if no answers are reported at all. Hint: Choose
          all points to be stored in the kd-tree on the line $y=x$.

        \item
          Suppose that a data structure is needed that can answer triangular range queries, but only for triangles whose edges are horizontal,
          vertical, or have slope $+1$ or $-1$. Develop a linear size data structure that answers such range queries in $O(n^{3/4} + k)$ time, where
          $k$ is the number of points reported. Hint: Choose 4 coordinate axes in the plane and use a 4-dimensional kd-tree.
      \end{enumerate}
    \end{problem}

    \begin{solution}
      \begin{enumerate}
        \item

        \item
      \end{enumerate}
    \end{solution}
\end{enumerate}<++>
\end{document}


